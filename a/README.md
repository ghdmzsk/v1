# 代码演化过程
一个运算有 4 个过程，成住坏空，a01 和 a08 完整地表达了这 4 个过程。
a02 和 a07 就仅有成住坏，a03 和 a06 就仅有成住，a04 和 a05 就仅有成。

a01 - a04 的表达是通过抛异常来截断过程。a05 - a08 是以 case object 来截断过程。
前者的统计依据不存在相等判定，只有中止判定（scala 层面是 throw Exception），
后者判定是相等判定，不存在中断。

成是指主动数第一次到达零点之前的阶段，这个阶段只能观察到加减法。a04 和 a05 则是这个阶段。
他们的本质是一样的，不过计算的方式不同，一个依赖中断，一个依赖相等判定。

住指主动数第一次经过零点之后的阶段，也是运算演化的主要阶段。成住对应 a03 和 a06。

坏阶段对应后继不再产生的一刹那。其实对于 scala 来说是一刹那，对于有资源回收的代码而言是一个过程。
他负责回收主动数的所有资源，被动数的正数部分也会被回收。也就是三个禅天的崩塌。
成住坏对应 a02 和 a07。

空是仅剩下被动数的零部分一直运算下去的过程，是直到宇宙尽头的运算。与 a04 和 a05 的联系恰好相对。
a04 和 a05 是都可以产生结果，但是统计方式不同，在代码上也不同。a01 和 a08 在代码上一模一样。
但是 a01 是在空的阶段抛一个异常作为截断，是 a02 在坏阶段截断这个特征的一个延伸，所以他是可以统计结果的。
而 a08 是根据相等判断来决定停止的，所以其实 a08 的运算是无法统计结果的，或者说统计时间是无限的。

由 a01 到 a04 是阴性的流动，由 a05 到 a08 是一个阳性的重新补足各个阶段的阳性流动，a04 和 a05
的接口处是代码不同，统计结果一致，被视作由阴到阳的接口。
a01 和 a08 因为代码相同，被视作另外一个由阳到阴的接口，代码相同，统计结果不一致。
中间部分 a02 - a07，a03 - a06 也一一对应。形成一个长度为 4 的双头链表。

那疑问来了，为什么一个往下流动一个往上流动呢？因为中止机制是把运算从中截断，
是把完整运算逐步屏蔽的过程。case object 本身的意义是不需要 tail 的意思，
是 tail 后面仍有细节的意思。